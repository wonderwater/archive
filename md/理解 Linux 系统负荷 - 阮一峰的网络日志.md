> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.ruanyifeng.com](https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)

> 一、查看系统负荷

**一、查看系统负荷**

如果你的电脑很慢，你或许想查看一下，它的工作量是否太大了。

在 Linux 系统中，我们一般使用 uptime 命令查看（w 命令和 top 命令也行）。（另外，它们在苹果公司的 Mac 电脑上也适用。）

你在终端窗口键入 uptime，系统会返回一行信息。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073001.png)

这行信息的后半部分，显示 "load average"，它的意思是 "系统的平均负荷"，里面有三个数字，我们可以从中判断系统负荷是大还是小。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073003.png)

为什么会有三个数字呢？你从手册中查到，它们的意思分别是 1 分钟、5 分钟、15 分钟内系统的平均负荷。

如果你继续看手册，它还会告诉你，当 CPU 完全空闲的时候，平均负荷为 0；当 CPU 工作量饱和的时候，平均负荷为 1。

那么很显然，"load average" 的值越低，比如等于 0.2 或 0.3，就说明电脑的工作量越小，系统负荷比较轻。

但是，什么时候能看出系统负荷比较重呢？等于 1 的时候，还是等于 0.5 或等于 1.5 的时候？如果 1 分钟、5 分钟、15 分钟三个值不一样，怎么办？

**二、一个类比**

判断系统负荷是否过重，必须理解 load average 的真正含义。下面，我根据 "[Understanding Linux CPU Load](http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages)" 这篇文章，尝试用最通俗的语言，解释这个问题。

首先，假设最简单的情况，你的电脑只有一个 CPU，所有的运算都必须由这个 CPU 来完成。

那么，我们不妨把这个 CPU 想象成一座大桥，桥上只有一根车道，所有车辆都必须从这根车道上通过。（很显然，这座桥只能单向通行。）

系统负荷为 0，意味着大桥上一辆车也没有。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073004.png)

系统负荷为 0.5，意味着大桥一半的路段有车。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073005.png)

系统负荷为 1.0，意味着大桥的所有路段都有车，也就是说大桥已经 "满" 了。但是必须注意的是，直到此时大桥还是能顺畅通行的。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073006.png)

系统负荷为 1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的 70%。以此类推，系统负荷 2.0，意味着等待上桥的车辆与桥面的车辆一样多；系统负荷 3.0，意味着等待上桥的车辆是桥面车辆的 2 倍。总之，当系统负荷大于 1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073007.png)

CPU 的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是 CPU 的最大工作量；桥梁上的车辆，就是一个个等待 CPU 处理的进程（process）。

如果 CPU 每分钟最多处理 100 个进程，那么系统负荷 0.2，意味着 CPU 在这 1 分钟里只处理 20 个进程；系统负荷 1.0，意味着 CPU 在这 1 分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程以外，还有 70 个进程正排队等着 CPU 处理。

为了电脑顺畅运行，系统负荷最好不要超过 1.0，这样就没有进程需要等待了，所有进程都能第一时间得到处理。很显然，1.0 是一个关键值，超过这个值，系统就不在最佳状态了，你要动手干预了。

**三、系统负荷的经验法则**

1.0 是系统负荷的理想值吗？

不一定，系统管理员往往会留一点余地，当这个值达到 0.7，就应当引起注意了。经验法则是这样的：

当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化。

当系统负荷持续大于 1.0，你必须动手寻找解决办法，把这个值降下来。

当系统负荷达到 5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。

**四、多处理器**

上面，我们假设你的电脑只有 1 个 CPU。如果你的电脑装了 2 个 CPU，会发生什么情况呢？

2 个 CPU，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍。

还是用大桥来类比，两个 CPU 就意味着大桥有两根车道了，通车能力翻倍了。

![](https://www.ruanyifeng.com/blogimg/asset/201107/bg2011073008.png)

所以，2 个 CPU 表明系统负荷可以达到 2.0，此时每个 CPU 都达到 100% 的工作量。推广开来，n 个 CPU 的电脑，可接受的系统负荷最大为 n.0。

**五、多核处理器**

芯片厂商往往在一个 CPU 内部，包含多个 CPU 核心，这被称为多核 CPU。

在系统负荷方面，多核 CPU 与多 CPU 效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个 CPU、每个 CPU 有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过 1.0，就表明电脑正常运行。

怎么知道电脑有多少个 CPU 核心呢？

"cat /proc/cpuinfo" 命令，可以查看 CPU 信息。"grep -c'model name'/proc/cpuinfo" 命令，直接返回 CPU 的总核心数。

**六、最佳观察时长**

最后一个问题，"load average" 一共返回三个平均值 ----1 分钟系统负荷、5 分钟系统负荷，15 分钟系统负荷，---- 应该参考哪个值？

如果只有 1 分钟的系统负荷大于 1.0，其他两个时间段都小于 1.0，这表明只是暂时现象，问题不大。

如果 15 分钟内，平均系统负荷大于 1.0（调整 CPU 核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察 "15 分钟系统负荷"，将它作为电脑正常运行的指标。

==========================================

[参考文献]

1. [Understanding Linux CPU Load](http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages)

2. [Wikipedia - Load (computing)](https://en.wikipedia.org/wiki/Load_%28computing%29)

（完）